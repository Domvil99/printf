(libft.h)

#ifndef LIBFT_H
#define LIBFT_H

# include <unistd.h> //Para write ()
# include <stdlib.h> //Para Malloc () y free ()
# include <stddef.h> //Para size_t 

int        ft_isalpha(int c);
int        ft_isdigit(int c);
int        ft_isalnum(int c);
int        ft_isascii(int c);
int        ft_isprint(int c);
int        ft_toupper(int c);
int        ft_tolower(int c);
int        ft_strncmp(const char *s1, const char *s2, size_t n);
int	     ft_memcmp(const void *s1, const void *s2, size_t n);
int      ft_atoi(const char *str);
char       *ft_strchr(const char *s, int c);
char       *ft_strrchr(const char *s, int c);
char       *ft_strnstr(const char *haystack, const char *needle, size_t len);
char	*ft_strdup(const char *s);
void    *ft_memset(void *s, int c, size_t n);
void	    ft_bzero(void *s, size_t n);
void	    *ft_memcpy(void *dst, const void *src, size_t n);
void	    *ft_memmove(void *dst, const void *src, size_t n);
void        *ft_memchr(const void *s, int c, size_t n);
void        *ft_calloc(size_t count, size_t size);
size_t      ft_strlen(const char *s);
size_t	    ft_strlcpy(char *dst, const char *src, size_t dstsize);
size_t	    ft_strlcat(char *dst, const char *src, size_t dstsize);

// Parte 2 - Funciones adicionales
char	*ft_substr(char const *s, unsigned int start, size_t len);
char	*ft_strjoin(char const *s1, char const *s2);
char	*ft_strtrim(char const *s1, char const *set);
char	**ft_split(char const *s, char c);
char	*ft_itoa(int n);
char	*ft_strmapi(char const *s, char (*f)(unsigned int, char));
void	ft_striteri(char *s, void (*f)(unsigned int, char*));
void	ft_putchar_fd(char c, int fd);
void	ft_putstr_fd(char *s, int fd);
void	ft_putendl_fd(char *s, int fd);
void	ft_putnbr_fd(int n, int fd);

#endif

(Makefile)

NAME = libft.a
CC = cc
CFLAGS = -Wall -Werror -Wextra
AR = ar rcs
RM = rm -f

SRC = ft_strlen.c ft_isalpha.c ft_isdigit.c ft_isalnum.c ft_isascii.c ft_isprint.c \
      ft_toupper.c ft_tolower.c ft_memset.c ft_bzero.c ft_memcpy.c ft_memmove.c \
      ft_strchr.c ft_strrchr.c ft_strncmp.c ft_memchr.c ft_memcmp.c ft_strnstr.c \
      ft_strlcpy.c ft_strlcat.c ft_atoi.c ft_calloc.c ft_strdup.c ft_substr.c \
	  ft_strjoin.c ft_strtrim.c ft_split.c ft_itoa.c ft_strmapi.c ft_striteri.c \
	  ft_putchar_fd.c ft_putstr_fd.c ft_putendl_fd.c ft_putnbr_fd.c 

OBJ = $(SRC:.c=.o)

all: $(NAME)

$(NAME): $(OBJ)
	$(AR) $(NAME) $(OBJ)

clean:
	$(RM) $(OBJ)

fclean: clean
	$(RM) $(NAME)

re: fclean all


#include "libft.h"
int	ft_atoi(const char *str)
{
	int	i;
	int	sign;
	int	result;

	i = 0;
	sign = 1;
	result = 0;

	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		i++;

	if (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}

	while (str[i] >= '0' && str[i] <= '9')
	{
		result = result * 10 + (str[i] - '0');
		i++;
	}

	return (result * sign);
}

#include "libft.h"
void	ft_bzero(void *s, size_t n)
{
	ft_memset(s, 0, n);
}


#include "libft.h"
void	*ft_calloc(size_t count, size_t size)
{
	void	*ptr;

	if (count == 0 || size == 0)
		return (malloc(1));  // Devuelve un puntero válido que puede pasarse a free()

	ptr = malloc(count * size);
	if (!ptr)
		return (NULL);

	ft_memset(ptr, 0, count * size);
	return (ptr);
}


#include "libft.h"
int	ft_isalnum(int c)
{
	if (ft_isalpha(c) || ft_isdigit(c))
		return (1);
	return (0);
}  


#include "libft.h"
int	ft_isalpha(int c)
{
	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
		return (1);
	return (0);
}


#include "libft.h"
int	ft_isascii(int c)
{
	if (c >= 0 && c <= 127)
		return (1);
	return (0);
}


#include "libft.h"
int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	return (0);
}


#include "libft.h"
int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
		return (1);
	return (0);
}


#include "libft.h"
static size_t	ft_numlen(int n)
{
	size_t	len;

    len = 1;
    if(n > 0)
        len = 0;
	while(n)
	{
		len++;
		n /= 10;
	}
	return (len);
}


#include "libft.h"
char	*ft_itoa(int n)
{
	char		*str;
	size_t		len;
	long		nb;

	nb = n;
	len = ft_numlen(n);
	str = (char *)malloc(len + 1);
	if (!str)
		return (NULL);
	str[len] = '\0';
	if (nb < 0)
		nb = -nb;
	while (len--)
	{
		str[len] = '0' + (nb % 10);
		nb /= 10;
	}
	if (n < 0)
		str[0] = '-';
	return (str);
}

#include "libft.h"
void	*ft_memchr(const void *s, int c, size_t n)
{
	size_t			i;
	const unsigned char	*ptr;

	ptr = (const unsigned char *)s;
	i = 0;
	while (i < n)
	{
		if (ptr[i] == (unsigned char)c)
			return ((void *)(ptr + i));
		i++;
	}
	return (NULL);
}


#include "libft.h"
int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	size_t			i;
	const unsigned char	*ptr1;
	const unsigned char	*ptr2;

	ptr1 = (const unsigned char *)s1;
	ptr2 = (const unsigned char *)s2;
	i = 0;
	while (i < n)
	{
		if (ptr1[i] != ptr2[i])
			return (ptr1[i] - ptr2[i]);
		i++;
	}
	return (0);
}


#include "libft.h"
void	*ft_memcpy(void *dst, const void *src, size_t n)
{
	size_t	i;
	unsigned char	*d;
	const unsigned char	*s;

	if (!dst || !src)
		return (NULL);
	d = (unsigned char *)dst;
	s = (const unsigned char *)src;
	i = 0;
	while (i < n)
	{
		d[i] = s[i];
		i++;
	}
	return (dst);
}


#include "libft.h"
static void	ft_memmove_forward(unsigned char *d, const unsigned char *s, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n)
	{
		d[i] = s[i];
		i++;
	}
}

static void	ft_memmove_backward(unsigned char *d, const unsigned char *s, size_t n)
{
	while (n > 0)
	{
		n--;
		d[n] = s[n];
	}
}
void	*ft_memmove(void *dst, const void *src, size_t n)
{
	unsigned char		*d;
	const unsigned char	*s;

	if (!dst && !src)
		return (NULL);
	d = (unsigned char *)dst;
	s = (const unsigned char *)src;

	if (d > s)
		ft_memmove_backward(d, s, n);
	else
		ft_memmove_forward(d, s, n);
	return (dst);
}


#include "libft.h"
void	*ft_memset(void *s, int c, size_t n)
{
	size_t	i;
	unsigned char	*ptr;

	ptr = (unsigned char *)s;
	i = 0;
	while (i < n)
	{
		ptr[i] = (unsigned char)c;
		i++;
	}
	return (s);
}

#include "libft.h"
void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}


#include "libft.h"
void	ft_putendl_fd(char *s, int fd)
{
	if (!s)
		return;
	write(fd, s, ft_strlen(s));
	write(fd, "\n", 1);
}


#include "libft.h"
void	ft_putnbr_fd(int n, int fd)
{
	if (n == -2147483648) // Manejo de INT_MIN
	{
		write(fd, "-2147483648", 11);
		return;
	}
	if (n < 0) // Si es negativo, imprimimos '-' y convertimos a positivo
	{
		write(fd, "-", 1);
		n = -n;
	}
	if (n >= 10) // Si es mayor o igual a 10, llamamos recursivamente a la función
		ft_putnbr_fd(n / 10, fd);
	char c = (n % 10) + '0'; // Convertimos el último dígito a carácter
	write(fd, &c, 1);
}


#include "libft.h"
void	ft_putstr_fd(char *s, int fd)
{
	if (!s)
		return;
	write(fd, s, ft_strlen(s));
}


#include "libft.h"
static size_t	ft_word_count(char const *s, char c)
{
	size_t	count = 0;
	int		in_word = 0;

	while (*s)
	{
		if (*s != c && !in_word)
		{
			count++;
			in_word = 1;
		}
		else if (*s == c)
			in_word = 0;
		s++;
	}
	return (count);
}
static char	*ft_word_dup(const char *s, char c)
{
	size_t	len = 0;
	char	*word;

	while (s[len] && s[len] != c)
		len++;
	word = (char *)malloc(len + 1);
	if (!word)
		return (NULL);
	ft_memcpy(word, s, len);
	word[len] = '\0';
	return (word);
}
static void	ft_free_split(char **words, size_t i)
{
	while (i > 0)
		free(words[--i]);
	free(words);
}
char	**ft_split(char const *s, char c)
{
	char	**words;
	size_t	i = 0;

	if (!s)
		return (NULL);
	words = (char **)malloc(sizeof(char *) * (ft_word_count(s, c) + 1));
	if (!words)
		return (NULL);
	while (*s)
	{
		if (*s != c)
		{
			words[i] = ft_word_dup(s, c);
			if (!words[i++])
				return (ft_free_split(words, i - 1), NULL);
			while (*s && *s != c)
				s++;
		}
		else
			s++;
	}
	words[i] = NULL;
	return (words);
}


#include "libft.h"
char	*ft_strchr(const char *s, int c)
{
	while (*s)
	{
		if (*s == (char)c)
			return ((char *)s);
		s++;
	}
	if (c == '\0')
		return ((char *)s);
	return (NULL);
}


#include "libft.h"
char	*ft_strdup(const char *s)
{
	size_t	len;
	char	*copy;

	len = ft_strlen(s) + 1;
	copy = (char *)malloc(len);
	if (!copy)
		return (NULL);
	ft_memcpy(copy, s, len);
	return (copy);
}


#include "libft.h"
void	ft_striteri(char *s, void (*f)(unsigned int, char *))
{
	unsigned int	i;

	if (!s || !f)
		return;
	i = 0;
	while (s[i])
	{
		f(i, &s[i]);
		i++;
	}
}


#include "libft.h"
char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*joined;
	size_t	len;

	if (!s1 || !s2)
		return (NULL);
	len = ft_strlen(s1) + ft_strlen(s2) + 1;
	joined = (char *)malloc(len);
	if (!joined)
		return (NULL);
	ft_memcpy(joined, s1, ft_strlen(s1));
	ft_memcpy(joined + ft_strlen(s1), s2, ft_strlen(s2) + 1);
	return (joined);
}


#include "libft.h"
size_t	ft_strlcat(char *dst, const char *src, size_t dstsize)
{
	size_t	dst_len;
	size_t	src_len;
	size_t	i;

	dst_len = ft_strlen(dst);
	src_len = ft_strlen(src);
	if (dstsize <= dst_len)
		return (dstsize + src_len);
	i = 0;
	while (src[i] && (dst_len + i + 1) < dstsize)
	{
		dst[dst_len + i] = src[i];
		i++;
	}
	dst[dst_len + i] = '\0';
	return (dst_len + src_len);
}


#include "libft.h"
size_t	ft_strlcpy(char *dst, const char *src, size_t dstsize)
{
	size_t	i;

	if (!dst || !src)
		return (0);
	i = 0;
	while (i + 1 < dstsize && src[i])
	{
		dst[i] = src[i];
		i++;
	}
	if (dstsize > 0)
		dst[i] = '\0';
	return (ft_strlen(src));
}


#include "libft.h"
size_t	ft_strlen(const char *s)
{
	size_t	len;

	len = 0;
	while (s[len] != '\0')
		len++;
	return (len);
}


#include "libft.h"
char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	char	*new_str;
	size_t	i;

	if (!s || !f)
		return (NULL);
	new_str = (char *)malloc(ft_strlen(s) + 1);
	if (!new_str)
		return (NULL);
	i = 0;
	while (s[i])
	{
		new_str[i] = f(i, s[i]);
		i++;
	}
	new_str[i] = '\0';
	return (new_str);
}


#include "libft.h"
int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n && (s1[i] || s2[i]))
	{
		if ((unsigned char)s1[i] != (unsigned char)s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	return (0);
}


#include "libft.h"
char	*ft_strnstr(const char *haystack, const char *needle, size_t len)
{
	size_t	i;
	size_t	j;

	if (!*needle)
		return ((char *)haystack);
	i = 0;
	while (haystack[i] && i < len)
	{
		j = 0;
		while (haystack[i + j] == needle[j] && (i + j) < len)
		{
			if (!needle[j + 1])
				return ((char *)(haystack + i));
			j++;
		}
		i++;
	}
	return (NULL);
}

#include "libft.h"
char	*ft_strrchr(const char *s, int c)
{
	char	*last = NULL;

	while (*s)
	{
		if (*s == (char)c)
			last = (char *)s;
		s++;
	}
	if (c == '\0')
		return ((char *)s);
	return (last);
}


#include "libft.h"
char	*ft_strtrim(char const *s1, char const *set)
{
	size_t	start;
	size_t	end;
	char	*trimmed;

	if (!s1 || !set)
		return (NULL);
	start = 0;
	while (s1[start] && ft_strchr(set, s1[start])) // Usamos ft_strchr
		start++;
	end = ft_strlen(s1);
	while (end > start && ft_strchr(set, s1[end - 1])) // Usamos ft_strchr
		end--;
	trimmed = ft_substr(s1, start, end - start);
	return (trimmed);
}


#include "libft.h"
char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	char	*substr;
	size_t	s_len;

	if (!s)
		return (NULL);
	s_len = ft_strlen(s);
	if (start >= s_len)
		return (ft_strdup(""));
	if (len > s_len - start)
		len = s_len - start;
	substr = (char *)malloc(len + 1);
	if (!substr)
		return (NULL);
	ft_memcpy(substr, s + start, len);
	substr[len] = '\0';
	return (substr);
}


#include "libft.h"
int	ft_tolower(int c)
{
	if (c >= 'A' && c <= 'Z')
		return (c + 32);
	return (c);
}


#include "libft.h"
int	ft_toupper(int c)
{
	if (c >= 'a' && c <= 'z')
		return (c - 32);
	return (c);
}



(ft_printf.c)
#include "ft_printf.h"

int	ft_printf(const char *format, ...)
{
	va_list	args;
	int		i;
	int		printed;

	va_start(args, format);
	i = 0;
	printed = 0;
	while (format[i])
	{
		if (format[i] == '%' && format[i + 1])
		{
			i++;
			printed += handle_format(&format[i], args, &i);
		}
		else
			printed += write(1, &format[i], 1);
		i++;
	}
	va_end(args);
	return (printed);
}


(ft_printf.h)
#ifndef FT_PRINTF_H
# define FT_PRINTF_H

# include <stdarg.h>
# include <unistd.h>
# include <stdlib.h>
# include "libft.h"

typedef struct s_format
{
	int		left_align;
	int		zero_pad;
	int		width;
	int		precision;
	int		has_precision;
	int		plus;
	int		space;
	int		hash;
	char	type;
}	t_format;

int	ft_printf(const char *format, ...);
int	handle_format(const char *format, va_list args, int *i);
int	parse_format(const char *format, t_format *f);
int	print_char(va_list args, t_format f);
int	print_str(va_list args, t_format f);
int	print_int(va_list args, t_format f);

#endif


(handle_format.c)
#include "ft_printf.h"

int	handle_format(const char *format, va_list args, int *i)
{
	t_format	f;
	int			len;

	len = 0;
	*i += parse_format(format, &f);

	if (f.type == 'c')
		len += print_char(args, f);
	else if (f.type == 's')
		len += print_str(args, f);
	else if (f.type == 'd' || f.type == 'i')
		len += print_int(args, f);
	else if (f.type == 'u')
		len += print_unsigned(args, f);
	else if (f.type == 'x' || f.type == 'X')
		len += print_hex(args, f);
	else if (f.type == 'p')
		len += print_pointer(args, f);
	else if (f.type == '%')
		len += write(1, "%", 1);

	return (len);
}


(parse_format.c)
#include "libft.h"
#include "ft_printf.h"

static int	is_flag(char c)
{
	return (c == '-' || c == '0');
}

static int	is_type(char c)
{
	return (c == 'c' || c == 's' || c == 'p' || c == 'd' || c == 'i' ||
			c == 'u' || c == 'x' || c == 'X' || c == '%');
}

int	parse_format(const char *format, t_format *f)
{
	int	i = 0;

	*f = (t_format){0, 0, 0, 0, 0, 0, 0, 0, 0};

	while (is_flag(format[i]))
	{
		if (format[i] == '-')
			f->left_align = 1;
		else if (format[i] == '0')
			f->zero_pad = 1;
		i++;
	}

	while (ft_isdigit(format[i]))
	{
		f->width = f->width * 10 + (format[i] - '0');
		i++;
	}

	if (format[i] == '.')
	{
		f->has_precision = 1;
		i++;
		while (ft_isdigit(format[i]))
		{
			f->precision = f->precision * 10 + (format[i] - '0');
			i++;
		}
	}

	if (is_type(format[i]))
	{
		f->type = format[i];
		i++;
	}

	return (i);
}


(print_char.c)
#include "ft_printf.h"

int	print_char(va_list args, t_format f)
{
	char	c = (char)va_arg(args, int);
	int		len = 1;
	int		padding = (f.width > 1) ? f.width - 1 : 0;

	if (!f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	write(1, &c, 1);

	if (f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	return (len + ((f.width > 1) ? f.width - 1 : 0));
}


(print_int.c)
#include "ft_printf.h"

static void	print_padding(int count, char c)
{
	while (count-- > 0)
		write(1, &c, 1);
}

int	print_int(va_list args, t_format f)
{
	int		n = va_arg(args, int);
	char	*num_str;
	int		num_len;
	int		total_len = 0;
	int		is_negative = (n < 0);
	int		sign_printed = 0;

	// Convertimos el número a string
	num_str = ft_itoa(n < 0 ? -n : n);
	num_len = ft_strlen(num_str);

	// Caso especial: número 0 y precisión 0 → no imprimir nada
	if (f.has_precision && f.precision == 0 && n == 0)
	{
		free(num_str);
		num_str = "";
		num_len = 0;
	}

	// Calculamos ceros por precisión
	int	zero_pad = 0;
	if (f.has_precision && f.precision > num_len)
		zero_pad = f.precision - num_len;

	// Si no hay precisión pero hay zero_pad y no hay alineación izquierda
	if (!f.has_precision && f.zero_pad && !f.left_align && f.width > (num_len + is_negative))
		zero_pad = f.width - num_len - is_negative;

	// Calculamos longitud total del número con ceros y signo
	int	full_len = num_len + zero_pad + is_negative;

	// Añadir espacio o + si es positivo
	if (!is_negative && (f.plus || f.space))
		full_len++;

	// Padding con espacios si no hay alineación izquierda
	if (!f.left_align && f.width > full_len)
	{
		print_padding(f.width - full_len, ' ');
		total_len += f.width - full_len;
	}

	// Imprimir signo
	if (is_negative)
		write(1, "-", 1);
	else if (f.plus)
		write(1, "+", 1);
	else if (f.space)
		write(1, " ", 1);

	sign_printed = is_negative || f.plus || f.space;
	total_len += sign_printed;

	// Imprimir ceros
	print_padding(zero_pad, '0');
	total_len += zero_pad;

	// Imprimir número (si hay algo que imprimir)
	if (num_len > 0)
	{
		write(1, num_str, num_len);
		total_len += num_len;
	}

	// Padding a la derecha si hay alineación izquierda
	if (f.left_align && f.width > full_len)
	{
		print_padding(f.width - full_len, ' ');
		total_len += f.width - full_len;
	}

	if (num_len > 0)
		free(num_str);
	return (total_len);
}


(print_str.c)
#include "ft_printf.h"

int	print_str(va_list args, t_format f)
{
	char	*str = va_arg(args, char *);
	int		len;
	int		padding;

	if (!str)
		str = "(null)";
	len = ft_strlen(str);
	if (f.has_precision && f.precision < len)
		len = f.precision;

	padding = (f.width > len) ? f.width - len : 0;

	if (!f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	write(1, str, len);

	if (f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	return (len + ((f.width > len) ? f.width - len : 0));
}


(print_unsigned.c)
#include "ft_printf.h"

static char	*ft_utoa(unsigned int n)
{
	int		len = 1;
	unsigned int tmp = n;
	while (tmp /= 10)
		len++;
	char *str = malloc(len + 1);
	if (!str)
		return NULL;
	str[len] = '\0';
	while (len--)
	{
		str[len] = '0' + (n % 10);
		n /= 10;
	}
	return str;
}

int	print_unsigned(va_list args, t_format f)
{
	unsigned int	n = va_arg(args, unsigned int);
	char			*str = ft_utoa(n);
	int				num_len = ft_strlen(str);
	int				zero_pad = 0;
	int				total = 0;

	if (f.has_precision && f.precision == 0 && n == 0)
	{
		free(str);
		str = "";
		num_len = 0;
	}

	if (f.has_precision && f.precision > num_len)
		zero_pad = f.precision - num_len;

	if (!f.has_precision && f.zero_pad && !f.left_align && f.width > num_len)
		zero_pad = f.width - num_len;

	int full_len = num_len + zero_pad;
	int space_pad = (f.width > full_len) ? f.width - full_len : 0;

	if (!f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	while (zero_pad-- > 0)
		write(1, "0", 1);

	if (num_len > 0)
		write(1, str, num_len);

	if (f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	total = (f.width > full_len) ? f.width : full_len;
	free(str);
	return total;
}


(print_hex.c)
#include "ft_printf.h"

static void	put_hex(unsigned int n, int upper)
{
	char *base = upper ? "0123456789ABCDEF" : "0123456789abcdef";
	if (n >= 16)
		put_hex(n / 16, upper);
	write(1, &base[n % 16], 1);
}

static int	count_digits_hex(unsigned int n)
{
	int count = 1;
	while (n >= 16)
	{
		n /= 16;
		count++;
	}
	return count;
}

int	print_hex(va_list args, t_format f)
{
	unsigned int	n = va_arg(args, unsigned int);
	int				digits = (f.has_precision && f.precision == 0 && n == 0) ? 0 : count_digits_hex(n);
	int				zero_pad = (f.has_precision && f.precision > digits) ? f.precision - digits : 0;
	int				prefix = (f.hash && n != 0) ? 2 : 0;
	int				total_len = digits + zero_pad + prefix;
	int				space_pad = (f.width > total_len) ? f.width - total_len : 0;

	if (!f.left_align && (!f.zero_pad || f.has_precision))
		while (space_pad-- > 0)
			write(1, " ", 1);

	if (prefix)
		write(1, f.type == 'x' ? "0x" : "0X", 2);

	if (!f.left_align && f.zero_pad && !f.has_precision)
		while (space_pad-- > 0)
			write(1, "0", 1);

	while (zero_pad-- > 0)
		write(1, "0", 1);

	if (digits > 0)
		put_hex(n, f.type == 'X');

	if (f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	return (f.width > total_len) ? f.width : total_len;
}


(print_pointer.c)
#include "ft_printf.h"

static void	put_ptr(unsigned long n)
{
	char *base = "0123456789abcdef";
	if (n >= 16)
		put_ptr(n / 16);
	write(1, &base[n % 16], 1);
}

static int	count_digits_ptr(unsigned long n)
{
	int count = 1;
	while (n >= 16)
	{
		n /= 16;
		count++;
	}
	return count;
}

int	print_pointer(va_list args, t_format f)
{
	unsigned long	ptr = (unsigned long)va_arg(args, void *);
	int				digits = (f.has_precision && f.precision == 0 && ptr == 0) ? 0 : count_digits_ptr(ptr);
	int				total_len = digits + 2;
	int				space_pad = (f.width > total_len) ? f.width - total_len : 0;

	if (!f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	write(1, "0x", 2);
	if (digits > 0)
		put_ptr(ptr);

	if (f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	return (f.width > total_len) ? f.width : total_len;
}


(print_binary_bonus.c)
#include "ft_printf.h"

static void	put_binary(unsigned int n)
{
	if (n >= 2)
		put_binary(n / 2);
	write(1, (n % 2) ? "1" : "0", 1);
}

int	print_binary(va_list args, t_format f)
{
	unsigned int	n = va_arg(args, unsigned int);
	unsigned int	tmp = n;
	int				digits = (n == 0) ? 1 : 0;
	int				zero_pad = 0;
	int				total = 0;

	while (tmp)
	{
		tmp /= 2;
		digits++;
	}

	if (f.has_precision && f.precision > digits)
		zero_pad = f.precision - digits;

	int	full_len = digits + zero_pad;
	int	space_pad = (f.width > full_len) ? f.width - full_len : 0;

	if (!f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	while (zero_pad-- > 0)
		write(1, "0", 1);

	if (digits > 0)
		put_binary(n);

	if (f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	total = (f.width > full_len) ? f.width : full_len;
	return total;
}

(print_n_bonus.c)
#include "ft_printf.h"

int	print_n(va_list args, int printed_so_far)
{
	int	*ptr = va_arg(args, int *);
	if (ptr)
		*ptr = printed_so_far;
	return 0;
}

(print_reverse_bonus.c)
#include "ft_printf.h"

int	print_reverse(va_list args, t_format f)
{
	char	*str = va_arg(args, char *);
	int		len = 0;
	int		padding;

	if (!str)
		str = "(null)";
	len = ft_strlen(str);
	if (f.has_precision && f.precision < len)
		len = f.precision;

	padding = (f.width > len) ? f.width - len : 0;

	if (!f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	while (len--)
		write(1, &str[len], 1);

	if (f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	return (f.width > ft_strlen(str)) ? f.width : ft_strlen(str);
}


(handle_format_bonus.c)
#include "ft_printf.h"

int	handle_format(const char *format, va_list args, int *i)
{
	t_format	f;
	int			len;

	len = 0;
	*i += parse_format(format, &f);

	if (f.type == 'c')
		len += print_char(args, f);
	else if (f.type == 's')
		len += print_str(args, f);
	else if (f.type == 'd' || f.type == 'i')
		len += print_int(args, f);
	else if (f.type == 'u')
		len += print_unsigned(args, f);
	else if (f.type == 'x' || f.type == 'X')
		len += print_hex(args, f);
	else if (f.type == 'p')
		len += print_pointer(args, f);
	else if (f.type == '%')
		len += write(1, "%", 1);
	else if (f.type == 'b')
		len += print_binary(args, f);
	else if (f.type == 'n')
		len += print_n(args, len);
	else if (f.type == 'r')
		len += print_reverse(args, f);

	return (len);
}


(parse_format_bonus.c)
#include "libft.h"
#include "ft_printf.h"

static int	is_flag(char c)
{
	return (c == '-' || c == '0' || c == '+' || c == ' ' || c == '#');
}

static int	is_type(char c)
{
	return (c == 'c' || c == 's' || c == 'p' || c == 'd' || c == 'i' ||
			c == 'u' || c == 'x' || c == 'X' || c == '%' ||
			c == 'b' || c == 'n' || c == 'r');
}

int	parse_format(const char *format, t_format *f)
{
	int	i = 0;

	*f = (t_format){0, 0, 0, 0, 0, 0, 0, 0, 0};

	while (is_flag(format[i]))
	{
		if (format[i] == '-')
			f->left_align = 1;
		else if (format[i] == '0')
			f->zero_pad = 1;
		else if (format[i] == '+')
			f->plus = 1;
		else if (format[i] == ' ')
			f->space = 1;
		else if (format[i] == '#')
			f->hash = 1;
		i++;
	}

	while (ft_isdigit(format[i]))
	{
		f->width = f->width * 10 + (format[i] - '0');
		i++;
	}

	if (format[i] == '.')
	{
		f->has_precision = 1;
		i++;
		while (ft_isdigit(format[i]))
		{
			f->precision = f->precision * 10 + (format[i] - '0');
			i++;
		}
	}

	if (is_type(format[i]))
	{
		f->type = format[i];
		i++;
	}

	return (i);
}


(print_char_bonus.c)
#include "ft_printf.h"

int	print_char(va_list args, t_format f)
{
	char	c = (char)va_arg(args, int);
	int		len = 1;
	int		padding = (f.width > 1) ? f.width - 1 : 0;

	if (!f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	write(1, &c, 1);

	if (f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	return (len + ((f.width > 1) ? f.width - 1 : 0));
}


(print_str_bonus.c)
#include "ft_printf.h"

int	print_str(va_list args, t_format f)
{
	char	*str = va_arg(args, char *);
	int		len;
	int		padding;

	if (!str)
		str = "(null)";
	len = ft_strlen(str);
	if (f.has_precision && f.precision < len)
		len = f.precision;

	padding = (f.width > len) ? f.width - len : 0;

	if (!f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	write(1, str, len);

	if (f.left_align)
		while (padding-- > 0)
			write(1, " ", 1);

	return (f.width > len) ? f.width : len;
}


(print_int_bonus.c)
#include "ft_printf.h"

static void	print_padding(int count, char c)
{
	while (count-- > 0)
		write(1, &c, 1);
}

int	print_int(va_list args, t_format f)
{
	int		n = va_arg(args, int);
	char	*num_str;
	int		num_len;
	int		total_len = 0;
	int		is_negative = (n < 0);
	int		sign_printed = 0;

	// Convertimos el número a string
	num_str = ft_itoa(n < 0 ? -n : n);
	num_len = ft_strlen(num_str);

	// Caso especial: número 0 y precisión 0 → no imprimir nada
	if (f.has_precision && f.precision == 0 && n == 0)
	{
		free(num_str);
		num_str = "";
		num_len = 0;
	}

	// Calculamos ceros por precisión
	int	zero_pad = 0;
	if (f.has_precision && f.precision > num_len)
		zero_pad = f.precision - num_len;

	// Si no hay precisión pero hay zero_pad y no hay alineación izquierda
	if (!f.has_precision && f.zero_pad && !f.left_align && f.width > (num_len + is_negative))
		zero_pad = f.width - num_len - is_negative;

	// Calculamos longitud total del número con ceros y signo
	int	full_len = num_len + zero_pad + is_negative;

	// Añadir espacio o + si es positivo
	if (!is_negative && (f.plus || f.space))
		full_len++;

	// Padding con espacios si no hay alineación izquierda
	if (!f.left_align && f.width > full_len)
	{
		print_padding(f.width - full_len, ' ');
		total_len += f.width - full_len;
	}

	// Imprimir signo
	if (is_negative)
		write(1, "-", 1);
	else if (f.plus)
		write(1, "+", 1);
	else if (f.space)
		write(1, " ", 1);

	sign_printed = is_negative || f.plus || f.space;
	total_len += sign_printed;

	// Imprimir ceros
	print_padding(zero_pad, '0');
	total_len += zero_pad;

	// Imprimir número (si hay algo que imprimir)
	if (num_len > 0)
	{
		write(1, num_str, num_len);
		total_len += num_len;
	}

	// Padding a la derecha si hay alineación izquierda
	if (f.left_align && f.width > full_len)
	{
		print_padding(f.width - full_len, ' ');
		total_len += f.width - full_len;
	}

	if (num_len > 0)
		free(num_str);
	return (total_len);
}


(print_unsigned_bonus.c)
#include "ft_printf.h"

static char	*ft_utoa(unsigned int n)
{
	int		len = 1;
	unsigned int tmp = n;
	while (tmp /= 10)
		len++;
	char *str = malloc(len + 1);
	if (!str)
		return NULL;
	str[len] = '\0';
	while (len--)
	{
		str[len] = '0' + (n % 10);
		n /= 10;
	}
	return str;
}

int	print_unsigned(va_list args, t_format f)
{
	unsigned int	n = va_arg(args, unsigned int);
	char			*str = ft_utoa(n);
	int				num_len = ft_strlen(str);
	int				zero_pad = 0;
	int				total = 0;

	if (f.has_precision && f.precision == 0 && n == 0)
	{
		free(str);
		str = "";
		num_len = 0;
	}

	if (f.has_precision && f.precision > num_len)
		zero_pad = f.precision - num_len;

	if (!f.has_precision && f.zero_pad && !f.left_align && f.width > num_len)
		zero_pad = f.width - num_len;

	int full_len = num_len + zero_pad;
	int space_pad = (f.width > full_len) ? f.width - full_len : 0;

	if (!f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	while (zero_pad-- > 0)
		write(1, "0", 1);

	if (num_len > 0)
		write(1, str, num_len);

	if (f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	total = (f.width > full_len) ? f.width : full_len;
	free(str);
	return total;
}


(print_hex_bonus.c)
#include "ft_printf.h"

static void	put_hex(unsigned int n, int upper)
{
	char *base = upper ? "0123456789ABCDEF" : "0123456789abcdef";
	if (n >= 16)
		put_hex(n / 16, upper);
	write(1, &base[n % 16], 1);
}

static int	count_digits_hex(unsigned int n)
{
	int count = 1;
	while (n >= 16)
	{
		n /= 16;
		count++;
	}
	return count;
}

int	print_hex(va_list args, t_format f)
{
	unsigned int	n = va_arg(args, unsigned int);
	int				digits = (f.has_precision && f.precision == 0 && n == 0) ? 0 : count_digits_hex(n);
	int				zero_pad = (f.has_precision && f.precision > digits) ? f.precision - digits : 0;
	int				prefix = (f.hash && n != 0) ? 2 : 0;
	int				total_len = digits + zero_pad + prefix;
	int				space_pad = (f.width > total_len) ? f.width - total_len : 0;

	if (!f.left_align && (!f.zero_pad || f.has_precision))
		while (space_pad-- > 0)
			write(1, " ", 1);

	if (prefix)
		write(1, f.type == 'x' ? "0x" : "0X", 2);

	if (!f.left_align && f.zero_pad && !f.has_precision)
		while (space_pad-- > 0)
			write(1, "0", 1);

	while (zero_pad-- > 0)
		write(1, "0", 1);

	if (digits > 0)
		put_hex(n, f.type == 'X');

	if (f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	return (f.width > total_len) ? f.width : total_len;
}


(print_pointer_bonus.c)
#include "ft_printf.h"

static void	put_ptr(unsigned long n)
{
	char *base = "0123456789abcdef";
	if (n >= 16)
		put_ptr(n / 16);
	write(1, &base[n % 16], 1);
}

static int	count_digits_ptr(unsigned long n)
{
	int count = 1;
	while (n >= 16)
	{
		n /= 16;
		count++;
	}
	return count;
}

int	print_pointer(va_list args, t_format f)
{
	unsigned long	ptr = (unsigned long)va_arg(args, void *);
	int				digits = (f.has_precision && f.precision == 0 && ptr == 0) ? 0 : count_digits_ptr(ptr);
	int				total_len = digits + 2;
	int				space_pad = (f.width > total_len) ? f.width - total_len : 0;

	if (!f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	write(1, "0x", 2);
	if (digits > 0)
		put_ptr(ptr);

	if (f.left_align)
		while (space_pad-- > 0)
			write(1, " ", 1);

	return (f.width > total_len) ? f.width : total_len;
}


(Makefile)
NAME        = libftprintf.a

SRC         = ft_printf.c handle_format.c parse_format.c print_char.c print_str.c print_int.c \
              print_unsigned.c print_hex.c print_pointer.c print_binary.c print_n.c print_reverse.c

BONUS_SRC   = handle_format_bonus.c parse_format_bonus.c print_char_bonus.c \
              print_str_bonus.c print_int_bonus.c print_unsigned_bonus.c \
              print_hex_bonus.c print_pointer_bonus.c print_binary_bonus.c \
              print_n_bonus.c print_reverse_bonus.c

OBJ         = $(SRC:.c=.o)
BONUS_OBJ   = $(BONUS_SRC:.c=.o)

LIBFT       = libft/libft.a

CC          = cc
CFLAGS      = -Wall -Wextra -Werror
AR          = ar rcs
RM          = rm -f

# Compilación estándar
all: $(NAME)

$(NAME): $(OBJ)
	make -C libft
	$(AR) $(NAME) $(OBJ) $(LIBFT)

# Compilación con bonus
bonus: $(OBJ) $(BONUS_OBJ)
	make -C libft
	$(AR) $(NAME) $(OBJ) $(BONUS_OBJ) $(LIBFT)

# Limpieza
clean:
	$(RM) $(OBJ) $(BONUS_OBJ)
	make clean -C libft

fclean: clean
	$(RM) $(NAME)
	make fclean -C libft

re: fclean all